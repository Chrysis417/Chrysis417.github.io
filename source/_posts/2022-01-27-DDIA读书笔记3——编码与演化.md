---
title: DDIA读书笔记3——编码与演化
catalog: true
comments: true
indexing: true
header-img: ../../../../img/default.jpg
top: false
tocnum: true
date: 2022-01-27 10:35:42
subtitle:
tags:
- DDIA
- 数据库
categories:
- 读书笔记
- 数据库
---
# 编码
将数据写入文件或发送至不共享内存的另一个进程时,由于没有内存、指针等结构来描述数据,需要建立一套编码协议来进行数据传送.例如XML,json，csv等

## 二进制编码

语言内置的编码库存在以下问题：

> 与特定编程语言绑定，不够灵活

> 要求解码过程能够实例化任意的类，导致安全问题

> 向前向后兼容问题

> 效率低下

因此开发出了一些通用编码格式，xml json等

对于计算机，效率最高，开销最小的编码是二进制编码

以下是一些与json等价的二进制编码算法

### MessagePack
使用1个字节来标识类型与长度。例如用a8(16进制)表示**长度为8**的**字符串**，83(16进制)表示**3个条目**的**对象**

保留了json模式中的所有信息，将数据转换成十六进制并加上类型与长度描述

### Thrift 与 Protocol Buffer
在MessagePack的基础上，用一个数字来标识条目的名称，而不再把名称本身也作为数据进行编码

### Avro
编码上，Avro继续从上述编码算法改进，取消了标识条目名称，只编码数据的长度，以及两种数据类型array,union

array就是若干个相同类型的数据，union用于标识该字段属于的类型，不属于这两种类型的只用一个字节来标识长度。

那么如何在不传送条目名称、标记的情况下来读写数据呢？Avro提出了读模式和写模式，压缩编码长度的同时解决向前向后兼容问题

#### 读模式与写模式
当应用程序使用Avro解码编码数据时，通信双方首先确定读模式与写模式的版本，在接下来的通信生命周期内就使用该版本的读模式与写模式通信

写模式规定了发送方按什么顺序编码待发送数据，读模式规定接收方按什么顺序从将接受到的数据填入对象的各个属性。读写模式会通过解析字段名匹配字段。

读写模式可以是不同的版本，只需注意兼容问题

模式可以存在本地数据库中，通过版本号来读取模式本身

为保持兼容性，只能添加或删除具有默认值的字段：

> 读模式读到不认识的字段，直接忽略；

> 读模式发现接受到的数据中缺少某些字段的数据，填入默认值；

使用读模式写模式容易更新数据库模式，假如使用Thrift或Protocol buffer,可能需要重新分配字段标签。

## 数据流模式
使用上述的编码方法，将数据从一个进程传递到另一个进程

### 基于数据库
数据库经常遇见新代码写入，旧代码读取的问题，因此也需要向前向后兼容

#### 归档存储
定时为数据库创建快照，用于备份或加载到数据仓库。

### 基于服务调用
服务器通过网络公开API，客户端连接到服务器以发出请求的过程就是基于服务调用的数据流

API预先确定了输入和输出

#### 面向服务的体系结构SOA/微服务体系结构
一个服务需要另一个服务的数据或功能时，可以向另一个服务发出请求。这就是被称作SOA的应用程序构建方式

一个需要达成的目标是使服务可独立部署和演化，新旧版本的服务器和客户端同时运行。因此API的数据编码格式需要注意

#### Web服务

##### REST
REST是一个基于HTTP的设计理念

使用URL来标识资源，使用HTTP协议进行缓存控制，身份验证等

##### SOAP
SOAP是基于XML的协议，目的是独立于HTTP

SOAP的API使用WSDL(一种基于XML的语言)来描述

### 远程过程调用RPC
网络请求与本地函数的调用是相当不同的：

> 网络请求是不可预测的，很可能丢包或失败，而本地函数调用具有可掌控性

> 网络请求的响应速度是不可预测的

> 网络请求无法使用指针等参数描述数据

> 客户端和服务可以使用不同的编程语言实现，导致数据类型的转换问题

### 异步消息传递 消息队列
在消息在进程之间传递的过程中，引入称为消息代理(或消息队列)的中间件的中介，该中介暂存消息

具有以下优势

> 充当缓冲区，当接收方过载或不可用时缓冲消息

> 自动重发消息到崩溃的进程，防止信息丢失

> 避免通信双方需要知道对方的ip地址和port

> 可以将一条消息发给多个接收方

> 在逻辑上分离发送方和接收方

消息队列中的消息只包含一些元数据和字节序列，可以使用任何编码格式

#### 分布式Actor框架
每个Actor实例代表一个客户端或实体，不关心每个Actor具体在哪个进程上

每个Actor使用相同的消息传递机制，不保证消息传送成功

每个Actor一次只处理一条消息