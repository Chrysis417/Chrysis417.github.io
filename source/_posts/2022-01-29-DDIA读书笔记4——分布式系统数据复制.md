---
title: DDIA读书笔记4——分布式系统数据复制
catalog: true
comments: true
indexing: true
header-img: ../../../../img/default.jpg
top: false
tocnum: true
date: 2022-01-29 16:27:56
subtitle:
tags:
- DDIA
- 数据库
categories:
- 读书笔记
- 数据库
---

Chapter5.数据复制

> 本笔记中**库**和**节点**两个词可能交替使用，含义等价

# 分布式数据系统特征
- 扩展性：分散读写吞吐或存储的负载
> 对单台机器提高性能称为垂直扩展。但是成本并非随性能线性增长，往往性能增加一倍成本增加好几倍

> 水平扩展就是一般意义上的分布式架构 
- 容错性：提供容错冗余，一台机器出错后冗余组件可迅速接管
- 降低延迟：在地理位置相距较大的不同地区部署服务，以方便用户访问最近的数据中心

- 复制
> 在多个节点上保存相同数据副本

- 分区
> 将一个大块头的数据库拆分成多个子集

# 数据复制

三种主流复制方案：主从复制，多主节点复制，无主节点复制

## 主从复制
主从复制原理广泛运用于数据库（内置支持），例如MySql，还运用于分布式消息队列如Kafka，RabbitMQ
### 工作原理
- 从多个数据副本中选择一个作为主节点，写入操作只向该副本执行。其他节点作为从节点，从用户视角来看是只读的

- 主副本完成写入操作后，把日志传给从节点，从节点根据日志更新数据，严格按照与主副本相同的写入顺序

这里引入一个重要问题：同步复制与异步复制

### 同步复制与异步复制
可以类比TCP和UDP

- (全)同步复制：主节点完成写入后，将日志传送给从节点，在此期间**阻塞其他写入操作，且从节点暂未完成的写入不被客户端所见**，等待其他从节点发来更新成功的消息才继续进行写入操作。最后，由主节点来通知用户数据更新情况

> 采用全同步复制会导致出现任何一个节点故障使整个系统停滞的问题

> 优点是任何一个副本都有最新的数据

- (全)异步复制：主节点发送完日志后不等待从库的回复

> 被实际上广泛使用的方法

> 主节点发生故障时可能会导致写入丢失的严重状况，为此引入了链式复制，一种同步复制的变体

- 链式复制：多个副本按一种单链表式的结构排列，写入操作向头节点进行，读操作和写入完成(向客户端)报告由尾节点进行，更新日志一级一级从头节点向后传。链式复制不是一个完整的复制方案，需要配合其他配置使用

> head故障时，head移交给其子节点即可。写入的数据要么已经被向下传递，要么由客户端重发请求

> tail故障也类似，tail移交给其父节点

> 中间节点故障则将其移除，若有写操作传入故障节点且还未向后传递，则由前一个节点重发

- 半同步复制：一个从节点进行同步复制，其他节点异步复制

此处还可以引入强一致和弱一致的概念：

get请求可以得到最近一次完成的put请求写入的值,被称为强一致。

弱一致是指，不保证get请求可以得到最近一次完成的put请求写入的值。

构建一个弱一致的系统也是非常有用的,为了保持强一致的通信，代价可能会非常高,因为每次你执行put或者get请求，你都需要等待几十毫秒来与数据的两个副本通信，以确保它们都被更新了或者都被检查了以获得最新的数据

### 配置新的从节点
- 对某个时间点的主节点产生一个快照，将此快照发送到新从节点

- 从节点连接主节点，拉取快照之后的新变化

### 处理节点宕机
确认节点宕机通常使用响应时间，若响应时间大于某一个值（超时），则认为其宕机（除非是为维护主库而故意关闭）

- 从库失效：从库从日志中获得宕机前处理的最后一项事务，重启后连接主库，拉取该事务之后的新变化，并逐一应用

- 主库失效:将一个从库提升为主库，重新配置客户端，并将客户端的写入请求传给新主库

> 选择新主库通常遵循数据损失最小原则（选择拥有最新数据副本的从库），由所有节点同意一个新主库。原主库恢复后，让原主库成为从库，并认可新的主节点

处理主库失效的过程称为故障切换。故障切换会带来很多问题。例如：

- 若使用异步复制，新的主节点还没有收到原主节点的写入，主库宕机期间收到的更新该如何处理？丢弃写入内容是相当危险的;

- 因为原主节点还未意识到主节点的改变，新主节点可能收到冲突的写请求;

- 从节点被提升为新主节点，但是由于数据未和原主节点完全同步，导致分配了原主节点已经分配出去的计数器，导致被外部应用错误引用;

- 可能出现两个节点都认为自己是主库(被称作脑裂);

- 超时的响应时间应该定为多少？

这些问题没有简单的处理方案，所以一般团队更倾向于使用手动故障切换。

以上问题是分布式数据库的基本问题，在第8，9章深入讨论。

### 复制日志的实现
主从复制技术的实现方式。如何记录日志以同步不同的副本？有以下方式

- 基于语句的复制：日志直接记录执行过的sql语句

> 由于每个副本的场景(例如计数器的值，当地时间)不一样，相同的语句在不同的库上可能产生不同的作用，需要一些手段来保证这些不确定性操作的结果

> 由于逻辑紧凑，依然在用

- 基于预写日志WAL的复制：所有对数据库写入的字节序列被记入日志，如第三章的LSM树和B树

> 缺点在于日志描述过于底层，例如记录了哪些磁盘块的哪些字节发生改变，兼容性较差

- 基于行的日志复制：用一系列数据描述行级别的改变

> 对行插入，包含所有插入的新值

> 对行删除，记录足够信息唯一标识被删除的行，通常是主键。若没有定义主键，记录所有列的旧值

> 对行更新，记录足够信息唯一标识更新的行，以及所有列的新值

> 这是一种逻辑日志，使复制与存储逻辑上分离。基于逻辑日志的复制有利于外部应用程序对日志的解析

- 基于触发器的复制：涉及代码层面，允许数据库在发生数据更改时执行一些已经定义好的代码

> 灵活性非常强，同时开销比较大也容易出错

> 可以编写代码将更改的数据存入另一个单独的表中

### 复制滞后问题

对于主库-从库并且使用异步同步的数据库结构来说，很容易出现相同的查询在不同的数据库上结果不同。

以下介绍这个问题的3中典型情况

1. 用户读刚刚写入的修改：

用户不希望自己刚写入的东西在查询时看不到修改。需要读写一致性来保证用户总能看到自己提交的修改。

可能的解决方案：

- 读用户能够更改的内容时，都从主库读，否则在从节点读；

- 在用户更新完的一分钟内的查询从主库读，解决应用大部分内容被所有用户更改的情况；

- 客户端记住写入时间戳，确保用户查询的那个库的内容已经至少更新到写入时间戳处。

还有其他问题，如跨设备同步，跨网络线路同步

2. 单调读一致性：

用户的每一次刷新可能都是从不同的库读取，可能造成一种“时光倒流”的效果，例如刚才还看到的评论，刷新一下没了。

解决方法：

- 确保每个用户只从同一个库读取。

3. 前缀一致读：

用户可能先看到问题的回答才看到问题。就是qq的发送顺序不一致情况。

解决方案：

- 需要一致前缀读保证：一系列顺序的写入，在显示时也要按顺序显示。

一种方案是确保所有因果相关的写入都存储于同一个库。在后续章节会继续探讨这个话题。

## 多主节点复制
主从复制有一个明显的缺点:主节点过于重要，假如与主节点的通信出现问题，所有的写入操作都会被影响

作为一种自然的扩展，可以配置多个主节点

### 适用场景

- 多数据中心：在每个数据中心配置一个主节点，一个数据中心内部采用主从复制方案，数据中心之间由主节点来与其他主节点进行数据交换更新（有点类似计网里面自治域AS的概念）
相比主从复制：

> 提升了写入性能(因为一个数据中心作为一个整体，只需保证当前数据中心内部的一致性)

> 能够容忍数据中心的失效，每个数据中心独立于其他数据中心运行

> 容忍网络问题

当然多主复制有一个最大的问题：冲突。不同数据中心可能会同时修改相同数据

- 离线客户端操作与协作编辑：把本地系统作为一个数据中心，并异步同步到数据库。

### 处理写冲突
- 避免冲突：应用层保证对特定记录的写请求总是通过一个主节点

> 由于其他方案总是存在瑕疵，避免冲突反而成为首选方案

- 对每个写入或每个副本分配一个id，选择其中1个id作为最终结果。但这意味着数据丢失

- 自定义处理：用一种数据结构保留冲突中所有的信息，并编写代码来处理，例如通知用户。

- 分为写时执行和读时执行：写时即写入时告知用户或由程序选择处理，读时执行则先将所有的写入存入，读时进行处理（用户选择或自动选择）。

- 自动冲突解决

#### 复制的拓扑结构
多主节点的三种拓扑结构：环形拓扑，星形拓扑，All-to-All拓扑

- 环形拓扑和星形拓扑

