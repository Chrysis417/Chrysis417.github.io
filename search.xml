<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>背包问题</title>
      <link href="/2022/02/10/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/10/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><p>定义dp[N+1][V+1]在前N件物品中任取，使得V容积的背包价值最大</p><p>遍历顺序逐物品或是逐容积都可以，算法保证信息来源都是已知项</p><p>注意到递推公式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(j-weight[i]&gt;&#x3D;0)&#123;</span><br><span class="line">dp[j]&#x3D;max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]);</span><br><span class="line">&#125;</span><br><span class="line">else dp[i-1][j]&#x3D;dp[j];</span><br></pre></td></tr></table></figure></p><p>中总是使用上一层的数据计算下一层，完全可以只使用一层的数据，二维N*V的dp数组可以简化成一维数组</p><p>但是不能简单的删去递推公式中的第一个维度，将dp[i][j]删为dp[j]，还要更改遍历顺序</p><p>这是因为二维数组中，作为信息来源的上一层不会被更改，而一位数组每遍历一项都可能更改这一项，作为“上一层”的信息被更改，造成递推错误。</p><p>改进方法为从右往左遍历，因为信息来源总是位于“左边”的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; weight.size(); i++) &#123; &#x2F;&#x2F; 遍历物品</span><br><span class="line">    for(int j &#x3D; bagWeight; j &gt;&#x3D; weight[i]; j--) &#123; &#x2F;&#x2F; 遍历背包容量</span><br><span class="line">        dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>在01背包中，我们从右往左遍历，目的是防止同样的物品被二次添加。在完全背包中，物品没有数量限制，就从左往右遍历，反而让物品可以多次添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先遍历背包，再遍历物品</span><br><span class="line">for(int j &#x3D; 0; j &lt;&#x3D; bagWeight; j++) &#123; &#x2F;&#x2F; 遍历背包容量</span><br><span class="line">    for(int i &#x3D; 0; i &lt; weight.size(); i++) &#123; &#x2F;&#x2F; 遍历物品</span><br><span class="line">        if (j - weight[i] &gt;&#x3D; 0) dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>完全背包用滚动数组写。完全没有用二维数组的必要和可行性。</p><h1 id="组合数-排列数问题"><a href="#组合数-排列数问题" class="headerlink" title="组合数/排列数问题"></a>组合数/排列数问题</h1><p>前两个代码实例求的是最大价值。若要求的是凑出目标重量（或价值，这种问题一般重量和价值的含义是一样的）的组合数，则递推公式部分需改为：</p><p>(以下代码i指代硬币种类数，j指代容量)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;此时求得组合数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dp[0]&#x3D;1是硬性规定，没有这个初始化后面没法推</span><br><span class="line">dp[0]&#x3D;1;</span><br><span class="line">for(int i&#x3D;0;i&lt;coins.size();i++)&#123;&#x2F;&#x2F;前i种硬币</span><br><span class="line">for(int j&#x3D;1;j&lt;&#x3D;amount;j++)&#123;&#x2F;&#x2F;包容量</span><br><span class="line">if(j&gt;&#x3D;coins[i]) dp[j]+&#x3D;dp[j-coins[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>递推公式，我的理解：</p><p>dp[j]+=dp[j-coins[i];</p><p>等价于</p><p>dp[i][j]=dp[i-1][j] + dp[i][j-nums[i]];</p><p>dp[i-j][j]:</p><ul><li><p>此时只存在i-1种硬币</p></li><li><p>上次迭代时，容量也为j</p></li><li><p>上一次填满容量为j的背包时，第i种硬币还不存在</p></li></ul><p>dp[i][j-nums[i]]：</p><ul><li><p>这次循环，新增了第i种硬币。如何在数值上体现第i种硬币的存在呢？已经求出了j-nums[i]容量时填满包的方法数，再在此基础上加一枚nums[i]，就得到了使用新硬币，一共i种硬币后的方法数</p></li><li><p>若j-nums[i]&lt;0，说明这个容量下使用不了这种新硬币</p></li><li><p>为什么两者相加？后者的值为添加了一种新硬币后，使用该硬币带来的新的组合可能数，“+=”意味着添加了新的可能。</p></li></ul><p>倘若把两层for交换顺序，则得到的是排列数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;此时求得排列数</span><br><span class="line">for (int j &#x3D; 0; j &lt;&#x3D; amount; j++) &#123; &#x2F;&#x2F; 遍历背包容量</span><br><span class="line">    for (int i &#x3D; 0; i &lt; coins.size(); i++) &#123; &#x2F;&#x2F; 遍历物品</span><br><span class="line">        if (j - coins[i] &gt;&#x3D; 0) dp[j] +&#x3D; dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDIA读书笔记4——分布式系统数据复制</title>
      <link href="/2022/01/29/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/"/>
      <url>/2022/01/29/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Chapter5.数据复制</p><blockquote><p>本笔记中<strong>库</strong>和<strong>节点</strong>两个词可能交替使用，含义等价</p></blockquote><h1 id="分布式数据系统特征"><a href="#分布式数据系统特征" class="headerlink" title="分布式数据系统特征"></a>分布式数据系统特征</h1><blockquote><p>扩展性：分散读写吞吐或存储的负载</p></blockquote><ul><li><p>对单台机器提高性能称为垂直扩展。但是成本并非随性能线性增长，往往性能增加一倍成本增加好几倍</p></li><li><p>水平扩展就是一般意义上的分布式架构 </p></li></ul><blockquote><p>容错性：提供容错冗余，一台机器出错后冗余组件可迅速接管</p><p>降低延迟：在地理位置相距较大的不同地区部署服务，以方便用户访问最近的数据中心</p><p>复制:在多个节点上保存相同数据副本</p><p>分区:将一个大块头的数据库拆分成多个子集</p></blockquote><h1 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h1><p>三种主流复制方案：主从复制，多主节点复制，无主节点复制</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从复制原理广泛运用于数据库（内置支持），例如MySql，还运用于分布式消息队列如Kafka，RabbitMQ</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li><p>从多个数据副本中选择一个作为主节点，写入操作只向该副本执行。其他节点作为从节点，从用户视角来看是只读的</p></li><li><p>主副本完成写入操作后，把日志传给从节点，从节点根据日志更新数据，严格按照与主副本相同的写入顺序</p></li></ul><p>这里引入一个重要问题：同步复制与异步复制</p><h3 id="同步复制与异步复制"><a href="#同步复制与异步复制" class="headerlink" title="同步复制与异步复制"></a>同步复制与异步复制</h3><p>可以类比TCP和UDP</p><blockquote><p>(全)同步复制：主节点完成写入后，将日志传送给从节点，在此期间<strong>阻塞其他写入操作，且从节点暂未完成的写入不被客户端所见</strong>，等待其他从节点发来更新成功的消息才继续进行写入操作。最后，由主节点来通知用户数据更新情况</p></blockquote><ul><li><p>采用全同步复制会导致出现任何一个节点故障使整个系统停滞的问题</p></li><li><p>优点是任何一个副本都有最新的数据</p></li></ul><blockquote><p>(全)异步复制：主节点发送完日志后不等待从库的回复</p></blockquote><ul><li><p>被实际上广泛使用的方法</p></li><li><p>主节点发生故障时可能会导致写入丢失的严重状况，为此引入了链式复制，一种同步复制的变体</p></li></ul><blockquote><p>链式复制：多个副本按一种单链表式的结构排列，写入操作向头节点进行，读操作和写入完成(向客户端)报告由尾节点进行，更新日志一级一级从头节点向后传。链式复制不是一个完整的复制方案，需要配合其他配置使用</p></blockquote><ul><li><p>head故障时，head移交给其子节点即可。写入的数据要么已经被向下传递，要么由客户端重发请求</p></li><li><p>tail故障也类似，tail移交给其父节点</p></li><li><p>中间节点故障则将其移除，若有写操作传入故障节点且还未向后传递，则由前一个节点重发</p></li></ul><blockquote><p>半同步复制：一个从节点进行同步复制，其他节点异步复制</p></blockquote><p>此处还可以引入强一致和弱一致的概念：</p><p>get请求可以得到最近一次完成的put请求写入的值,被称为强一致。</p><p>弱一致是指，不保证get请求可以得到最近一次完成的put请求写入的值。</p><p>构建一个弱一致的系统也是非常有用的,为了保持强一致的通信，代价可能会非常高,因为每次你执行put或者get请求，你都需要等待几十毫秒来与数据的两个副本通信，以确保它们都被更新了或者都被检查了以获得最新的数据</p><h3 id="配置新的从节点"><a href="#配置新的从节点" class="headerlink" title="配置新的从节点"></a>配置新的从节点</h3><p>对某个时间点的主节点产生一个快照，将此快照发送到新从节点</p><p>从节点连接主节点，拉取快照之后的新变化</p><h3 id="处理节点宕机"><a href="#处理节点宕机" class="headerlink" title="处理节点宕机"></a>处理节点宕机</h3><p>确认节点宕机通常使用响应时间，若响应时间大于某一个值（超时），则认为其宕机（除非是为维护主库而故意关闭）</p><blockquote><p>从库失效：从库从日志中获得宕机前处理的最后一项事务，重启后连接主库，拉取该事务之后的新变化，并逐一应用</p><p>主库失效:将一个从库提升为主库，重新配置客户端，并将客户端的写入请求传给新主库</p></blockquote><ul><li>选择新主库通常遵循数据损失最小原则（选择拥有最新数据副本的从库），由所有节点同意一个新主库。原主库恢复后，让原主库成为从库，并认可新的主节点</li></ul><p>处理主库失效的过程称为故障切换。故障切换会带来很多问题。例如：</p><ul><li><p>若使用异步复制，新的主节点还没有收到原主节点的写入，主库宕机期间收到的更新该如何处理？丢弃写入内容是相当危险的;</p></li><li><p>因为原主节点还未意识到主节点的改变，新主节点可能收到冲突的写请求;</p></li><li><p>从节点被提升为新主节点，但是由于数据未和原主节点完全同步，导致分配了原主节点已经分配出去的计数器，导致被外部应用错误引用;</p></li><li><p>可能出现两个节点都认为自己是主库(被称作脑裂);</p></li><li><p>超时的响应时间应该定为多少？</p></li></ul><p>这些问题没有简单的处理方案，所以一般团队更倾向于使用手动故障切换。</p><p>以上问题是分布式数据库的基本问题，在第8，9章深入讨论。</p><h3 id="复制日志的实现"><a href="#复制日志的实现" class="headerlink" title="复制日志的实现"></a>复制日志的实现</h3><p>主从复制技术的实现方式。如何记录日志以同步不同的副本？有以下方式</p><blockquote><p>基于语句的复制：日志直接记录执行过的sql语句</p></blockquote><ul><li><p>由于每个副本的场景(例如计数器的值，当地时间)不一样，相同的语句在不同的库上可能产生不同的作用，需要一些手段来保证这些不确定性操作的结果</p></li><li><p>由于逻辑紧凑，依然在用</p></li></ul><blockquote><p>基于预写日志WAL的复制：所有对数据库写入的字节序列被记入日志，如第三章的LSM树和B树</p></blockquote><ul><li>缺点在于日志描述过于底层，例如记录了哪些磁盘块的哪些字节发生改变，兼容性较差</li></ul><blockquote><p>基于行的日志复制：用一系列数据描述行级别的改变</p></blockquote><ul><li><p>对行插入，包含所有插入的新值</p></li><li><p>对行删除，记录足够信息唯一标识被删除的行，通常是主键。若没有定义主键，记录所有列的旧值</p></li><li><p>对行更新，记录足够信息唯一标识更新的行，以及所有列的新值</p></li><li><p>这是一种逻辑日志，使复制与存储逻辑上分离。基于逻辑日志的复制有利于外部应用程序对日志的解析</p></li></ul><blockquote><p>基于触发器的复制：涉及代码层面，允许数据库在发生数据更改时执行一些已经定义好的代码</p></blockquote><ul><li><p>灵活性非常强，同时开销比较大也容易出错</p></li><li><p>可以编写代码将更改的数据存入另一个单独的表中</p></li></ul><h3 id="复制滞后问题"><a href="#复制滞后问题" class="headerlink" title="复制滞后问题"></a>复制滞后问题</h3><p>对于主库-从库并且使用异步同步的数据库结构来说，很容易出现相同的查询在不同的数据库上结果不同。</p><p>以下介绍这个问题的3种典型情况</p><blockquote><p>用户读刚刚写入的修改：</p></blockquote><p>用户不希望自己刚写入的东西在查询时看不到修改。需要读写一致性来保证用户总能看到自己提交的修改。</p><p>可能的解决方案：</p><ul><li><p>读用户能够更改的内容时，都从主库读，否则在从节点读；</p></li><li><p>在用户更新完的一分钟内的查询从主库读，解决应用大部分内容被所有用户更改的情况；</p></li><li><p>客户端记住写入时间戳，确保用户查询的那个库的内容已经至少更新到写入时间戳处。</p></li></ul><p>还有其他问题，如跨设备同步，跨网络线路同步</p><blockquote><p>单调读一致性：</p></blockquote><p>用户的每一次刷新可能都是从不同的库读取，可能造成一种“时光倒流”的效果，例如刚才还看到的评论，刷新一下没了。</p><p>解决方法：确保每个用户只从同一个库读取。</p><blockquote><p>前缀一致读：</p></blockquote><p>用户可能先看到问题的回答才看到问题。就是qq的发送顺序不一致情况。</p><p>解决方案：</p><ul><li><p>需要一致前缀读保证：一系列顺序的写入，在显示时也要按顺序显示。</p></li><li><p>一种方案是确保所有因果相关的写入都存储于同一个库。在后续章节会继续探讨这个话题。</p></li></ul><h2 id="多主节点复制"><a href="#多主节点复制" class="headerlink" title="多主节点复制"></a>多主节点复制</h2><p>主从复制有一个明显的缺点:主节点过于重要，假如与主节点的通信出现问题，所有的写入操作都会被影响</p><p>作为一种自然的扩展，可以配置多个主节点</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><blockquote><p>多数据中心：在每个数据中心配置一个主节点，一个数据中心内部采用主从复制方案，数据中心之间由主节点来与其他主节点进行数据交换更新（有点类似计网里面自治域AS的概念）</p></blockquote><p>相比主从复制：</p><ul><li><p>提升了写入性能(因为一个数据中心作为一个整体，只需保证当前数据中心内部的一致性)</p></li><li><p>能够容忍数据中心的失效，每个数据中心独立于其他数据中心运行</p></li><li><p>容忍网络问题</p></li></ul><p>当然多主复制有一个最大的问题：冲突。不同数据中心可能会同时修改相同数据</p><blockquote><p>离线客户端操作与协作编辑：把本地系统作为一个数据中心，并异步同步到数据库。</p></blockquote><h3 id="处理写冲突"><a href="#处理写冲突" class="headerlink" title="处理写冲突"></a>处理写冲突</h3><blockquote><p>避免冲突：应用层保证对特定记录的写请求总是通过一个主节点</p></blockquote><p>由于其他方案总是存在瑕疵，避免冲突反而成为首选方案</p><blockquote><p>对每个写入或每个副本分配一个id，选择其中1个id作为最终结果。但这意味着数据丢失</p><p>自定义处理：用一种数据结构保留冲突中所有的信息，并编写代码来处理，例如通知用户。</p><p>分为写时执行和读时执行：写时即写入时告知用户或由程序选择处理，读时执行则先将所有的写入存入，读时进行处理（用户选择或自动选择）。</p><p>自动冲突解决</p></blockquote><h4 id="复制的拓扑结构"><a href="#复制的拓扑结构" class="headerlink" title="复制的拓扑结构"></a>复制的拓扑结构</h4><p>多主节点的三种拓扑结构：环形拓扑，星形拓扑，All-to-All拓扑</p><h2 id="无主节点复制"><a href="#无主节点复制" class="headerlink" title="无主节点复制"></a>无主节点复制</h2><p>无主节点，即允许任何副本接受写入。</p><p>优势场合：高可用，低延时，允许读到旧值。合理配置法定人数(见后文)可以使数据库无须故障切换，容忍部分副本故障。</p><h3 id="节点失效时的写入"><a href="#节点失效时的写入" class="headerlink" title="节点失效时的写入"></a>节点失效时的写入</h3><p>当一些副本宕机时，从这一刻开始的写入就会被丢失，因此，当客户端请求读取时，可能得到多个副本的不同响应，客户端可以通过版本号(见后文)确定最新值</p><p>如何修复这些落后的副本呢？</p><blockquote><p>读修复：客户端并行读取多个节点，检测到旧的节点时，将新值重新写回旧节点。适用于读频繁的系统</p><p>反熵过程：安排一个后台进程不断检测副本之间的数据差异，并将缺少的数据从一个副本复制到缺少的副本</p></blockquote><h3 id="法定人数quorum"><a href="#法定人数quorum" class="headerlink" title="法定人数quorum"></a>法定人数quorum</h3><p>一共n个副本，每次写入需要w个副本的认才认为写入成功，客户端读取时读r个副本.</p><p>这样，当w+r&gt;n时，总能确保有一个副本是最新的。这样的r和w值称为法定人数.</p><p>r和w越大，冗余程度越高，能容忍更多节点故障.</p><h4 id="宽松法定人数sloppy-quorum"><a href="#宽松法定人数sloppy-quorum" class="headerlink" title="宽松法定人数sloppy quorum"></a>宽松法定人数sloppy quorum</h4><p>在节点数大于n的集群中，把非“主”节点（即那n个节点之外的节点）作为可以暂用的节点，当“主”节点故障时，可以暂存在非主节点中，主节点修好了再把数据移交到其本应到的地方。</p><p>可以显著提高可用性.缺点是即使r+w&gt;n也会出现读旧值的情况</p><h3 id="监控旧值"><a href="#监控旧值" class="headerlink" title="监控旧值"></a>监控旧值</h3><p>在主从复制模型中，可以直接检测副本和领导者之间的滞后量，</p><p>但在无主复制中，很难检测陈旧度，有研究通过参数w和r来预测，但运用不广</p><h3 id="检测并发写"><a href="#检测并发写" class="headerlink" title="检测并发写"></a>检测并发写</h3><p>参照前文“处理写冲突”</p><h4 id="Lamport逻辑时钟"><a href="#Lamport逻辑时钟" class="headerlink" title="Lamport逻辑时钟"></a>Lamport逻辑时钟</h4><p>由于分布式系统中，不同节点地理位置可能相差甚远，以真实时间戳记录事件发生难以实现也无必要，因此提出了逻辑时钟的概念。</p><p>逻辑时钟就是以一个数字来记录逻辑上的事件发生顺序。</p><ol><li>节点A，B初始时钟为0</li><li>节点A上发生的事件a1时钟记录为C(a1)=1</li><li>事件a1发送给节点B，触发了节点B的事件b1，b1的时间戳就记为C(b1)=C(a1)+1=2</li><li>A上的时钟更新为2，B上时钟更新为3</li><li>对不同节点上时钟相同的事件，设置节点之间的优先级解决。如节点A和B上时间戳同为4的事件a2，b2,记为a2先发生</li><li>这样就得到了一组事件序列的全序关系</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDIA读书笔记3——编码与演化</title>
      <link href="/2022/01/27/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/"/>
      <url>/2022/01/27/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>将数据写入文件或发送至不共享内存的另一个进程时,由于没有内存、指针等结构来描述数据,需要建立一套编码协议来进行数据传送.例如XML,json，csv等</p><h2 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h2><p>语言内置的编码库存在以下问题：</p><blockquote><p>与特定编程语言绑定，不够灵活</p><p>要求解码过程能够实例化任意的类，导致安全问题</p><p>向前向后兼容问题</p><p>效率低下</p></blockquote><p>因此开发出了一些通用编码格式，xml json等</p><p>对于计算机，效率最高，开销最小的编码是二进制编码</p><p>以下是一些与json等价的二进制编码算法</p><h3 id="MessagePack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a>MessagePack</h3><p>使用1个字节来标识类型与长度。例如用a8(16进制)表示<strong>长度为8</strong>的<strong>字符串</strong>，83(16进制)表示<strong>3个条目</strong>的<strong>对象</strong></p><p>保留了json模式中的所有信息，将数据转换成十六进制并加上类型与长度描述</p><h3 id="Thrift-与-Protocol-Buffer"><a href="#Thrift-与-Protocol-Buffer" class="headerlink" title="Thrift 与 Protocol Buffer"></a>Thrift 与 Protocol Buffer</h3><p>在MessagePack的基础上，用一个数字来标识条目的名称，而不再把名称本身也作为数据进行编码</p><h3 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h3><p>编码上，Avro继续从上述编码算法改进，取消了标识条目名称，只编码数据的长度，以及两种数据类型array,union</p><p>array就是若干个相同类型的数据，union用于标识该字段属于的类型，不属于这两种类型的只用一个字节来标识长度。</p><p>那么如何在不传送条目名称、标记的情况下来读写数据呢？Avro提出了读模式和写模式，压缩编码长度的同时解决向前向后兼容问题</p><h4 id="读模式与写模式"><a href="#读模式与写模式" class="headerlink" title="读模式与写模式"></a>读模式与写模式</h4><p>当应用程序使用Avro解码编码数据时，通信双方首先确定读模式与写模式的版本，在接下来的通信生命周期内就使用该版本的读模式与写模式通信</p><p>写模式规定了发送方按什么顺序编码待发送数据，读模式规定接收方按什么顺序从将接受到的数据填入对象的各个属性。读写模式会通过解析字段名匹配字段。</p><p>读写模式可以是不同的版本，只需注意兼容问题</p><p>模式可以存在本地数据库中，通过版本号来读取模式本身</p><p>为保持兼容性，只能添加或删除具有默认值的字段：</p><blockquote><p>读模式读到不认识的字段，直接忽略；</p><p>读模式发现接受到的数据中缺少某些字段的数据，填入默认值；</p></blockquote><p>使用读模式写模式容易更新数据库模式，假如使用Thrift或Protocol buffer,可能需要重新分配字段标签。</p><h2 id="数据流模式"><a href="#数据流模式" class="headerlink" title="数据流模式"></a>数据流模式</h2><p>使用上述的编码方法，将数据从一个进程传递到另一个进程</p><h3 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h3><p>数据库经常遇见新代码写入，旧代码读取的问题，因此也需要向前向后兼容</p><h4 id="归档存储"><a href="#归档存储" class="headerlink" title="归档存储"></a>归档存储</h4><p>定时为数据库创建快照，用于备份或加载到数据仓库。</p><h3 id="基于服务调用"><a href="#基于服务调用" class="headerlink" title="基于服务调用"></a>基于服务调用</h3><p>服务器通过网络公开API，客户端连接到服务器以发出请求的过程就是基于服务调用的数据流</p><p>API预先确定了输入和输出</p><h4 id="面向服务的体系结构SOA-微服务体系结构"><a href="#面向服务的体系结构SOA-微服务体系结构" class="headerlink" title="面向服务的体系结构SOA/微服务体系结构"></a>面向服务的体系结构SOA/微服务体系结构</h4><p>一个服务需要另一个服务的数据或功能时，可以向另一个服务发出请求。这就是被称作SOA的应用程序构建方式</p><p>一个需要达成的目标是使服务可独立部署和演化，新旧版本的服务器和客户端同时运行。因此API的数据编码格式需要注意</p><h4 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h4><h5 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h5><p>REST是一个基于HTTP的设计理念</p><p>使用URL来标识资源，使用HTTP协议进行缓存控制，身份验证等</p><h5 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h5><p>SOAP是基于XML的协议，目的是独立于HTTP</p><p>SOAP的API使用WSDL(一种基于XML的语言)来描述</p><h3 id="远程过程调用RPC"><a href="#远程过程调用RPC" class="headerlink" title="远程过程调用RPC"></a>远程过程调用RPC</h3><p>网络请求与本地函数的调用是相当不同的：</p><blockquote><p>网络请求是不可预测的，很可能丢包或失败，而本地函数调用具有可掌控性</p><p>网络请求的响应速度是不可预测的</p><p>网络请求无法使用指针等参数描述数据</p><p>客户端和服务可以使用不同的编程语言实现，导致数据类型的转换问题</p></blockquote><h3 id="异步消息传递-消息队列"><a href="#异步消息传递-消息队列" class="headerlink" title="异步消息传递 消息队列"></a>异步消息传递 消息队列</h3><p>在消息在进程之间传递的过程中，引入称为消息代理(或消息队列)的中间件的中介，该中介暂存消息</p><p>具有以下优势</p><blockquote><p>充当缓冲区，当接收方过载或不可用时缓冲消息</p><p>自动重发消息到崩溃的进程，防止信息丢失</p><p>避免通信双方需要知道对方的ip地址和port</p><p>可以将一条消息发给多个接收方</p><p>在逻辑上分离发送方和接收方</p></blockquote><p>消息队列中的消息只包含一些元数据和字节序列，可以使用任何编码格式</p><h4 id="分布式Actor框架"><a href="#分布式Actor框架" class="headerlink" title="分布式Actor框架"></a>分布式Actor框架</h4><p>每个Actor实例代表一个客户端或实体，不关心每个Actor具体在哪个进程上</p><p>每个Actor使用相同的消息传递机制，不保证消息传送成功</p><p>每个Actor一次只处理一条消息</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典同步问题</title>
      <link href="/2022/01/24/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2022/01/24/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程、进程同步"><a href="#多线程、进程同步" class="headerlink" title="多线程、进程同步"></a>多线程、进程同步</h1><p>不同进程(或线程)访问同一个内存区域(临界区)时，会引发一些同步问题，如竞争条件</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>定义一个整型变量用于累计唤醒次数,称为信号量</p><p>定义一组操作：up与down，两者均为原子操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">down(semaphore* S)&#123;</span><br><span class="line">    S-&gt;value--;&#x2F;&#x2F;申请一个资源</span><br><span class="line">    if(S-&gt;value&lt;0)&#123;&#x2F;&#x2F;没有空闲资源</span><br><span class="line">        add this process to S-&gt;list;</span><br><span class="line">        block();&#x2F;&#x2F;阻塞该进程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">up(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value++;&#x2F;&#x2F;释放一个资源</span><br><span class="line">    if(S-&gt;value&lt;&#x3D;0)&#123;&#x2F;&#x2F;有进程被阻塞</span><br><span class="line">        remove a process P from S-&gt;list;</span><br><span class="line">        wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">sem_t sem, sem;</span><br><span class="line"></span><br><span class="line">sem_init(&amp;sem, 0, 0);</span><br><span class="line">sem_wait(&amp;sem);&#x2F;&#x2F;down</span><br><span class="line">sem_post(&amp;sem);&#x2F;&#x2F;up</span><br></pre></td></tr></table></figure><h2 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h2><p>有些应用划分出了若干执行阶段，并且规定，除非所有进程准备进入下一阶段，否则制造一个“屏障”，阻塞抵达屏障的进程。</p><p>执行步骤：</p><ol><li>进程接近屏障，并被阻塞</li><li>最后一个进程到达屏障，屏障解除，所有进程一起通过</li></ol><h2 id="互斥量——互斥锁与条件变量"><a href="#互斥量——互斥锁与条件变量" class="headerlink" title="互斥量——互斥锁与条件变量"></a>互斥量——互斥锁与条件变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">    生产者-消费者问题</span><br><span class="line">    缓冲区大小为1</span><br><span class="line">*&#x2F;</span><br><span class="line">#inlcude&lt;stdio.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_cond_t condc,dondp;</span><br><span class="line"></span><br><span class="line">int buffer&#x3D;0;</span><br><span class="line">&#x2F;*</span><br><span class="line">    根据 c++ 标准，在一个线程尝试对一个 mutex 对象进行 unlock 操作时，mutex 对象的所有权必须在这个线程上；</span><br><span class="line">    也就是说，应该由同一个线程来对一个 mutex 对象进行 lock 和 unlock 操作，否则会产生未定义行为</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">void *producer(void* ptr)&#123;</span><br><span class="line">    for(int i&#x3D;1;i&lt;10000001;i++)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);&#x2F;&#x2F;上锁</span><br><span class="line">        &#x2F;* </span><br><span class="line">            使用while进行双重判断:</span><br><span class="line">                a. 第一次判断buffer!&#x3D;0,不需要生产者生产，生产者阻塞在condp上(生产者线程被放入等待队列)，释放mutex</span><br><span class="line">                b. 当生产者被唤醒，进行第二次判断</span><br><span class="line">        *&#x2F;</span><br><span class="line">        while(buffer !&#x3D; 0) pthread_cond_wait(&amp;condp,&amp;mutex);</span><br><span class="line">        buffer&#x3D;i;</span><br><span class="line">        pthread_cond_signal(&amp;condc);&#x2F;&#x2F;唤醒消费者</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);&#x2F;&#x2F;解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void *consumer(void* ptr)&#123;</span><br><span class="line">    for(int i&#x3D;1;i&lt;10000001;i++)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        while(buffer &#x3D;&#x3D; 0) pthread_cond_wait(&amp;condp,&amp;mutex);</span><br><span class="line">        buffer&#x3D;0;</span><br><span class="line">        pthread_cond_signal(&amp;condp);&#x2F;&#x2F;唤醒生产者</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);&#x2F;&#x2F;解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    pthread_t pro,con;</span><br><span class="line">    pthread_mutex_init(&amp;mutex);</span><br><span class="line">    pthread_cond_init(&amp;condc,0);</span><br><span class="line">    pthread_cond_init(&amp;condp,0);</span><br><span class="line">    pthread_create(&amp;con,nullptr,consumer,nullptr);</span><br><span class="line">    pthread_create(&amp;con,nullptr,consumer,nullptr);</span><br><span class="line">    ...</span><br><span class="line">    pthread_cond_destroy(&amp;condc);</span><br><span class="line">    pthread_cond_destroy(&amp;condp);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">    思考：</span><br><span class="line">    有多个生产者的情景下，生产者1执行pthread_cond_wait()释放了锁，生产者2就能获得锁，于是多个生产者同时进入临界区，以上代码是否就失效了？</span><br><span class="line"></span><br><span class="line">    是的，这是双进程生产者-消费者情形的代码</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><h3 id="使用RAII机制管理mutex"><a href="#使用RAII机制管理mutex" class="headerlink" title="使用RAII机制管理mutex"></a>使用RAII机制管理mutex</h3><p>类似于python中的with关键字，用完资源(锁)后自动释放<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m;</span><br><span class="line"> </span><br><span class="line">void bad() </span><br><span class="line">&#123;</span><br><span class="line">    m.lock();                    &#x2F;&#x2F; acquire the mutex</span><br><span class="line">    f();                         &#x2F;&#x2F; if f() throws an exception, the mutex is never released</span><br><span class="line">    if(!everything_ok()) return; &#x2F;&#x2F; early return, the mutex is never released</span><br><span class="line">    m.unlock();                  &#x2F;&#x2F; if bad() reaches this statement, the mutex is released</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void good()</span><br><span class="line">&#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(m); &#x2F;&#x2F; RAII class: mutex acquisition is initialization</span><br><span class="line">    f();                               &#x2F;&#x2F; if f() throws an exception, the mutex is released</span><br><span class="line">    if(!everything_ok()) return;       &#x2F;&#x2F; early return, the mutex is released</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><p>异步操作是一种在不需要等待被调用方返回结果之前，就让操作继续进行下去的方法</p><p>future 和 promise 起源于函数式编程，其目的是将值（future）和计算方式（promise）分离，使得 promise 可以异步地修改 future，从而提高代码的可读性，并减少通信延迟</p><h2 id="哲学家就餐问题与读者-写者问题"><a href="#哲学家就餐问题与读者-写者问题" class="headerlink" title="哲学家就餐问题与读者-写者问题"></a>哲学家就餐问题与读者-写者问题</h2><h1 id="数据库读写同步"><a href="#数据库读写同步" class="headerlink" title="数据库读写同步"></a>数据库读写同步</h1><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><h2 id="污读"><a href="#污读" class="headerlink" title="污读"></a>污读</h2>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDIA读书笔记2——存储与检索</title>
      <link href="/2022/01/24/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/"/>
      <url>/2022/01/24/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>Chapter3.数据存储与检索</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是一种冗余存储，是用于加快数据查询的元数据，在加快查询的同时会提高写入开销。</p><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>简单的哈希过程，key为查询的关键字，如url，value为值或值所在的地址</p><p>一个视频的播放量就可以存储为key：视频url；value：播放量</p><h3 id="使用哈希索引日志文件"><a href="#使用哈希索引日志文件" class="headerlink" title="使用哈希索引日志文件"></a>使用哈希索引日志文件</h3><p>以键值对作为日志</p><p>日志文件使用顺序追加是合适的，因为：从磁盘角度，顺序写入比随机写入快的多；并发和崩溃回复容易得多；避免数据文件出现碎片化问题</p><p>同时也有局限性：哈希表必须全部放入内存，在磁盘上性能不好；不能区域查询</p><p>在日志大小增长到一定程度时，可以切成一个文件，称为段，每个段包含数据库在一段时间内写入的所有值，后台进程定期将多个段压缩合并，对同一个key取最新值。</p><p>崩溃恢复：由于哈希表存放在内存中，系统崩溃重启后丢失，因此可以将哈希表快照定期存储在磁盘上以加速恢复。</p><h3 id="LSM树"><a href="#LSM树" class="headerlink" title="LSM树"></a>LSM树</h3><p>SSTable：把上文的段存储更改为按键值排序存放</p><p>键值有顺序后，合并和查找更加高效：合并时从多个段文件同时读，把最小的键复制到新段中，重复这个过程;查找时，不需要存储所有的键，只需稀疏记录其中一些键，只需知道查找目标在某两个键之间。</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>一个超长的比特串，初始化为0</p><p>加入数据时，经过n个哈希函数计算将一些比特位置1,查询时，将待查数据哈希后，比对这些比特位即可快速判断数据是否已存在于数据库中</p><p>缺点：可能出现判断错误；无法删除</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>分段索引。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><blockquote><p>写时复制优化</p><p>B+树 ：保存键的缩略信息，例如中间页只需描述键的起止范围</p><p>添加额外指针：添加指向兄弟节点的指针</p><p>分形树</p></blockquote><h3 id="B树-vs-LSM树"><a href="#B树-vs-LSM树" class="headerlink" title="B树 vs LSM树"></a>B树 vs LSM树</h3><blockquote><p>B树是就地更新，lsm树是日志结构<br>b树写入较快，lsm树查询较快<br>b树写入数据至少需要写入两次，一次日志，一次写入树本身<br>b树中每个键只在一个位置，而lsm树的日志结构可能会让同一个键在不同位置</p></blockquote><p>lsm优点：</p><blockquote><p>lsm树由于反复压缩和合并SSTable，会不断使用固态硬盘的寿命（这种情况被称为写放大）<br>lsm树通常支持更高的写入吞吐量，部分原因是拥有较低的写放大<br>lsm树可以被更好的压缩，因此磁盘使用上更好（定期重写SSTable就是在压缩碎片）</p></blockquote><p>lsm缺点:</p><blockquote><p>压缩SSTable时可能干扰查询请求，所以响应时间的可预测较差</p></blockquote><h2 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h2><p>一级索引查询到user_id后，二级索引查询表中所有该用户的行</p><h2 id="在索引中存放值"><a href="#在索引中存放值" class="headerlink" title="在索引中存放值"></a>在索引中存放值</h2><p>聚集索引：在索引中直接保存数据</p><p>非聚集索引：在索引中保存数据的跳转</p><h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>哈希索引难以处理同时查询多项属性的情况。</p><p>引入多列索引，例如（日期，温度）上查询某日期范围内，某温度范围内的所有观测值</p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组读写操作，不一定具有ACID属性</p><p>ACID：原子性，事务中的所有操作要么全部完成要么全部不完成；一致性，事务开始前和结束后，数据库都是处于一致性状态的，不同数据库的状态都是相对应的；隔离性，一个事务的操作不能被另一个事务干扰；持久性，事务完成后结果将永久保存在数据库中，由恢复子系统保证。</p><h2 id="OLTP和OLAP"><a href="#OLTP和OLAP" class="headerlink" title="OLTP和OLAP"></a>OLTP和OLAP</h2><p>前者用于数据查询，后者用于数据分析</p><p>下文主要是OLAP方面的存储技术</p><h2 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h2><p>早期OLTP和OLAP都使用相同的数据库，后来一些大公司改用单独的数据库进行OLAP，这个单独的数据库称为数据仓库。数据从OLTP仓库中提取出来，转换为适合分析的模式，最终加载进数据仓库。</p><h3 id="星形分析模式"><a href="#星形分析模式" class="headerlink" title="星形分析模式"></a>星形分析模式</h3><p>在大型企业的交易表中，可能有几十PB的交易历史，其中大部分都是表</p><p>这些表由事实表和维度表组成</p><p>事实表记录了所有交易/访问等的事实，每一行都包括了一项交易/访问的具体信息，例如一个人买了3件商品，会在事实表中添加3条记录。</p><p>维度表是围绕在事实表旁的表，是事实表中每一列的补充属性。</p><p>例如事实表中存储date_key属性，维度表中就存储这个date_key具体是哪一天，是不是假期等等补充属性。</p><p>事实表中每项属性的值都是对维度表的外键引用。例如事实表中，date属性的值为141402，则在一个记录了日期信息，主键为date的维度表中，记录了key值为141402的日期具体是哪一天</p><h3 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h3><p>事实表非常大，可能有万亿行，几百列和PB级数据，而维度表通常小得多（数百万行</p><p>若查询只涉及到其中几列，使用列存储效率更高</p><p>列存储就是把事实表的一列作为一个文件存储</p><p>大多数OLTP数据库都是以面向行的方式存储的，即将来自一行的值存储在一起，而对OTAP，列存储可以显著加快专门的分析查询，所以正在快速普及</p><h4 id="列压缩"><a href="#列压缩" class="headerlink" title="列压缩"></a>列压缩</h4><h5 id="位图编码bitmap"><a href="#位图编码bitmap" class="headerlink" title="位图编码bitmap"></a>位图编码bitmap</h5><p>对每一个值存储一个数组，以1表示该值出现，0表示其他值</p><p>当行数较小时可以每一行都生成一位，在行数较大时则采用游程编码</p><h5 id="游程编码run-length-encoding"><a href="#游程编码run-length-encoding" class="headerlink" title="游程编码run-length encoding"></a>游程编码run-length encoding</h5><p>例如，在该列中，值29出现在第11，12位，记录值29的数组可表示为10，2</p><p>即10个0，2个1，后面都为0</p><p>采用这两种方法的原因是：行数一般远大于不同值的数量，百亿条交易记录中可能只有数十万种商品</p><p>在数据仓库的常见查询中，可以用到位图进行高效查询，例如：</p><p>WHERE product_sk IN（30，68，69）调用了30，68，69这3个位图</p><p>WHERE product_sk = 31 AND store_sk = 3 调用了31，3这2个位图</p><h5 id="内存带宽与矢量化处理"><a href="#内存带宽与矢量化处理" class="headerlink" title="内存带宽与矢量化处理"></a>内存带宽与矢量化处理</h5><p>列存储不仅能减少从磁盘加载的数据量，还有利于cache的使用。</p><p>列压缩后更多的行可以加载到高级cache中，上文中的AND，OR查询运算可直接在cache中操作。这种技术被称作矢量化处理</p><h4 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h4><p>列存储的存储顺序通常不太重要</p><p>若要排序，应当选择多列进行排序，单列排序没有意义。</p><p>比如对date_key和product两列进行排序才有了”同一天卖出的产品”这样的实际意义</p><h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p>面向列的压缩、存储、排序都有助于加速读取，但是让写入更加困难</p><p>书上说：使用LSM树，把排序后的写入写入磁盘，内存中的存储是面向行还是面向列的都行。 没看懂bruh</p><h3 id="数据立方体与物化视图"><a href="#数据立方体与物化视图" class="headerlink" title="数据立方体与物化视图"></a>数据立方体与物化视图</h3><p>物化视图的常见例子就是数据立方体</p><p>数据库中经常进行SUM，COUNT等聚合操作，因此可以把这些常用聚合直接缓存起来，就形成了数据立方体。</p><p>物化视图就是这样的一张表(视图)，内容是一些查询的结果，是基表的副本；也可以是虚拟视图，内容是查询的捷径，从虚拟视图读取时，sql引擎将其转换，展开为视图的底层查询</p><p>当底层数据发生变化时，物化视图也需要更新，所以增大了写入的开销，故OLTP数据库不经常使用物化视图</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDIA读书笔记1——数据模型与查询语言</title>
      <link href="/2022/01/23/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/"/>
      <url>/2022/01/23/DDIA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter2-数据模型与查询语言"><a href="#Chapter2-数据模型与查询语言" class="headerlink" title="Chapter2.数据模型与查询语言"></a>Chapter2.数据模型与查询语言</h1><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>NoSQL即”非sql”</p><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>目前最常用的数据库模型，将数据存储为表</p><p>面临的问题：<br>目前大多数应用开发采用面向对象的编程语言，而编程语言<strong>对象</strong>与关系模型<strong>表</strong>之间的转换非常麻烦</p><h3 id="文档模型"><a href="#文档模型" class="headerlink" title="文档模型"></a>文档模型</h3><p>适用于记录之间有一对多关系或没有关系</p><p>类似于json的模型，将数据存储为树结构</p><p>一对多关系就形成了树结构，例如简历上一个人有多份工作，多个教育经历</p><p>面临的问题：<br>应用程序需要频繁访问整个文档时效率高，但只访问其中一部分数据时效率低，因为数据库通常会加载整个文档</p><h3 id="图形模型"><a href="#图形模型" class="headerlink" title="图形模型"></a>图形模型</h3><p>适用于一对多与多对多关系很常见的数据，可以表示一些关系表中难以表示的关系、联系</p><p>图模型中包括顶点和边，若用关系表来表示可以分为两个表</p><h2 id="查询语言"><a href="#查询语言" class="headerlink" title="查询语言"></a>查询语言</h2><h3 id="命令式和声明式"><a href="#命令式和声明式" class="headerlink" title="命令式和声明式"></a>命令式和声明式</h3><p>命令式即编程语言，指导电脑每一步该怎么做</p><p>声明式即sql，声明将要完成的操作，具体实施交给底层</p><p>命令式对并发友好，且在源数据被更改的情况下命令式查询很可能出错，必须重写，而声明式没有这个问题</p><h3 id="MapReduce查询"><a href="#MapReduce查询" class="headerlink" title="MapReduce查询"></a>MapReduce查询</h3><p>（前几天还自己去啃论文，看得倒懂不懂的，DDIA上原来直接就有描述，太顶了）<br>MapReduce查询是一种底层查询模型，相对于sql等高级查询语言，高级语言是底层模型的应用</p><p>map函数会产生(emit,读原文就是看不明白这个单词)一个中间（intermediate)键值对，reduce函数则对这些中间键值对进行合并，具体来说就是把具有相同键的键值对进行求和等合并操作。</p><p>MapReduce是纯函数，只对传入的键值对进行操作，不执行额外查询操作。</p><p>MapReduce操作由一个主控程序控制，将map、reduce操作分别指派给不同的工作机器（worker）执行(联想到消费者-生产者？),并通过主机定时ping worker等操作来确保worker的正常工作，若worker宕机，再指派另一个worker执行前者的工作。</p><h3 id="图模型查询语言"><a href="#图模型查询语言" class="headerlink" title="图模型查询语言"></a>图模型查询语言</h3><p>就是沿着边不断访问其他顶点的过程</p><p>例如查找BORN_IN边指向美国，LIVING_IN指向欧洲的所有顶点</p><p>代表有Cypher。</p><p>由于图模型可以用两个关系表来表示，所以查询也可以用sql，但是存在一些困难</p><h3 id="三元存储"><a href="#三元存储" class="headerlink" title="三元存储"></a>三元存储</h3><p>三元存储的思想几乎和图模型一样</p><p>以(主，谓1，宾1，谓2，宾2，……)的形式存储</p><p>主体是图中一个顶点</p><p>宾语是值时，（谓语，宾语）可以是一个键值对，是主体的一项属性</p><p>宾语是图中另一个顶点时，谓语就是一条边</p><p>三元存储的查询语言有SPARQL，比Cypher更简洁</p><h3 id="Datalog"><a href="#Datalog" class="headerlink" title="Datalog"></a>Datalog</h3><p>是一项比较古老的语言。（但是古老的东西不代表思想古老，也许某时候会从老东西中获得启发）</p><p>存储思想类似于三元组<br>以 谓（主，宾）的形式存储，如name(usa,’United States’)</p><p>查询过程：对查询语句通过查询数据库，生成中间词条，再从中间词条查询出结果。从查询到结果中间可能有多步中间词条。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux线程信号与socket初探 --记计网实验udp实现tcp</title>
      <link href="/2022/01/22/linux%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/01/22/linux%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>计网课程实验：使用udp实现tcp。实验要求非常之宽泛，基本上就这一句，（高情商）给同学们提供了广阔的发挥空间，（低情商）也非常好水过 ╮(╯▽╰)╭</p><p>考虑到期末ddl集中以及个人知识储备，选择模拟tcp的超时重发。</p><p>从看懂老师发的参考代码到自己写出来还是花了有一点时间的，深刻认识到自己编码能力之弱鸡。但还是有必要记录一下用到的技术。</p><h1 id="高精度计时"><a href="#高精度计时" class="headerlink" title="高精度计时"></a>高精度计时</h1><h2 id="微秒级-秒级"><a href="#微秒级-秒级" class="headerlink" title="微秒级/秒级"></a>微秒级/秒级</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys&#x2F;time.h&gt;</span><br><span class="line"></span><br><span class="line">struct timeval start_time;</span><br><span class="line">struct timeval end_time;</span><br><span class="line">&#x2F;&#x2F;struct timeval存储的是从1970年到调用gettimeofday时的微秒数以及秒数</span><br><span class="line">gettimeofday(&amp;start_time, nullptr);</span><br><span class="line">function();&#x2F;&#x2F; do something</span><br><span class="line">gettimeofday(&amp;end_time, nullptr);</span><br><span class="line">time_t start_t&#x3D;start_time.tv_usec;&#x2F;&#x2F;秒级计时改为start_time.tv_sec即可</span><br><span class="line">time_t end_t&#x3D;start_time.tv_usec;&#x2F;&#x2F;同上</span><br><span class="line">time_t diff&#x3D;end_t-start_t;&#x2F;&#x2F;diff是最终的程序运行时间</span><br><span class="line">cout&lt;&lt;diff;</span><br></pre></td></tr></table></figure><h2 id="纳秒级"><a href="#纳秒级" class="headerlink" title="纳秒级"></a>纳秒级</h2><p>一般程序使用毫秒级的计时就足够了，不过C++11的chrono库提供了最高纳秒级计时。</p><p>当然chrono库也同时提供了毫秒级和微秒级的计时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">auto tp_start&#x3D;std::chrono::steady_clock::now();</span><br><span class="line">function(); &#x2F;&#x2F; do something</span><br><span class="line">auto tp_end&#x3D;std::chrono::steady_clock::now();</span><br><span class="line">auto nanos&#x3D;std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(tp_end-tp_start).count();</span><br><span class="line">cout&lt;&lt;nanos;</span><br></pre></td></tr></table></figure></p><h1 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h1><p>需要注意的是使用pthread后在编译时要加上 <strong>-pthread</strong> 参数</p><h2 id="向pthread传递参数"><a href="#向pthread传递参数" class="headerlink" title="向pthread传递参数"></a>向pthread传递参数</h2><p>就目前了解，向pthread传递参数只能是把参数封装在结构体中传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;&#x2F;&#x2F;sleep()</span><br><span class="line"></span><br><span class="line">struct thread_params&#123;</span><br><span class="line">    thread_params(int p1,string p2)&#123;</span><br><span class="line">        para1&#x3D;p1;</span><br><span class="line">        para2&#x3D;p2;</span><br><span class="line">    &#125;</span><br><span class="line">    int para1;</span><br><span class="line">    string para2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">pthread执行的方法只能是void*(void*)类型的，所以参数得进行强转</span><br><span class="line">指针包括地址和类型基本长度2个信息，void*则只有地址一个信息</span><br><span class="line">*&#x2F;</span><br><span class="line">void* thread_handler(void* args)&#123;</span><br><span class="line">    struct thread_params* params&#x3D;(thread_param*)args;</span><br><span class="line">    cout&lt;&lt;params-&gt;para1&lt;&lt;args-&gt;para2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    结构体也能使用new关键字创建</span><br><span class="line">    与class相比只有默认访问权限，以及使用意图不同</span><br><span class="line">    结构体甚至可以继承和拥有构造函数</span><br><span class="line">    *&#x2F;</span><br><span class="line">    pthread_t pid;</span><br><span class="line">    thread_params *args&#x3D;new thread_params(111,&quot;abc&quot;);</span><br><span class="line">    pthread_create(&amp;pid,NULL,thread_handler,(void*)args);</span><br><span class="line">    sleep(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pthread的阻塞与唤醒（使用信号"><a href="#pthread的阻塞与唤醒（使用信号" class="headerlink" title="pthread的阻塞与唤醒（使用信号)"></a>pthread的阻塞与唤醒（使用信号)</h2><p>主进程每过一个tv(time interval,单位为秒)执行一次sig_handler，使用pthread_kill唤醒线程的同时将tv翻倍</p><p>线程使用sigwait()阻塞，等待ALARM信号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;epoll.h&gt;</span><br><span class="line"></span><br><span class="line">void* thread_handler(void* args)&#123;</span><br><span class="line">    sigset_t set;</span><br><span class="line">    int sig;</span><br><span class="line">    sigemptyset(&amp;set);</span><br><span class="line">    &#x2F;&#x2F;设置能够接收的信号集，此处设为接收ALARM信号</span><br><span class="line">    sigaddset(&amp;set,SIGALARM);</span><br><span class="line">    pthread_sigmask(SIG_SETMASK,&amp;set,nullptr);</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        sigwait(&amp;set,&amp;sig);</span><br><span class="line">        std::cout&lt;&lt;&quot;thread awake&quot;&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">double tv&#x3D;0.2;</span><br><span class="line">int tv_sec,tv_usec;</span><br><span class="line">struct sigaction sa;</span><br><span class="line">struct itimerval itv;</span><br><span class="line">static void sig_handler(int sig)&#123;</span><br><span class="line">    &#x2F;&#x2F;唤醒线程</span><br><span class="line">    pthread_kill(resend_thread_id,SIGALRM);</span><br><span class="line">    &#x2F;&#x2F;间隔翻倍</span><br><span class="line">    tv*&#x3D;2;</span><br><span class="line">    tv_sec&#x3D;tv;</span><br><span class="line">    tv_usec&#x3D;(tv-tv_sec)*1e6;</span><br><span class="line">    itv.it_value.tv_sec &#x3D; tv_sec ;</span><br><span class="line">    itv.it_value.tv_usec &#x3D; tv_usec;</span><br><span class="line">    if (setitimer(ITIMER_REAL, &amp;itv, 0) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;setitimer()&quot; &lt;&lt; std::endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    pthread_create(&amp;pid,nullptr,thread_handler,nullptr);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags &#x3D; 0;</span><br><span class="line">    sa.sa_handler &#x3D; sig_handler;</span><br><span class="line">    if (sigaction(SIGALRM, &amp;sa, NULL) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;sigaction(SIGALRM, &amp;sa, NULL) &quot; &lt;&lt; endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    while(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="c-socket的初始化与使用"><a href="#c-socket的初始化与使用" class="headerlink" title="c++ socket的初始化与使用"></a>c++ socket的初始化与使用</h1><p>参考</p><ul><li><p>《UNIX环境高级编程(中文第三版)》第16章</p></li><li><p>《LINUX高性能服务器编程》</p></li></ul><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>int socket(int domain,int type,int protocol);</p><p>domain:网域</p><blockquote><p>AF_INET ipv4网域<br>AF_INET6 ipv6网域</p></blockquote><p>type:套接字类型</p><blockquote><p>SOCK_DGRAM 固定长度，无连接，不可靠的报文传递（默认网际协议UDP）<br>SOCK_STREAM 有序，可靠，双向，面向连接的字节流传递（默认网际协议TCP）<br>SOCK_SEQPACKET 固定长度，有序，可靠，面向连接的报文传递</p></blockquote><p>protocol:网际协议</p><blockquote><p>通常为0，表示由给定的域选择默认网际协议，也可以自定义</p></blockquote><p>执行到socket()函数时，操作系统会在文件系统中创建一个socket对象，这个socket对象包含了发送缓冲区、接收缓冲区、等待队列等成员。</p><p>等待队列指向所有需要等待该socket事件的进程(注意到此处是进程的引用)。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll是一种多路IO复用技术，用于提高服务端进程管理多个IO请求的效率(例如多个socket)</p><h3 id="多路IO复用"><a href="#多路IO复用" class="headerlink" title="多路IO复用"></a>多路IO复用</h3><p>I/O是指计算机中一个部件对另一个部件进行数据读写。</p><p>本次项目中用到的是网络编程中利用socket进行的IO：网卡接收到发来的数据，将其写入内存，并向cpu发出一个中断，cpu捕获了中断信号后，执行相应的处理程序。其他硬件产生的中断也是如此工作。</p><p>一个服务端往往需要处理多个客户端发起的多个请求，需要管理多个socket。使用传统的recv()函数会将进程阻塞在一个socket上(将该进程加入socket的等待队列中)，达不到并行处理多个socket的目的，因此引入了一种解决办法：多路IO复用技术。</p><p>另一种常用技术是多线程，此处不展开。</p><p>多路IO复用是同步、阻塞的。</p><h3 id="select-poll"><a href="#select-poll" class="headerlink" title="select/poll"></a>select/poll</h3><p>select()一般运作流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int s &#x3D; socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">bind(s, ...)</span><br><span class="line">listen(s, ...)</span><br><span class="line"> </span><br><span class="line">int fds[] &#x3D;  存放需要监听的socket</span><br><span class="line"> </span><br><span class="line">while(1)&#123;</span><br><span class="line">    int n &#x3D; select(..., fds, ...)</span><br><span class="line">    for(int i&#x3D;0; i &lt; fds.count; i++)&#123;</span><br><span class="line">        if(FD_ISSET(fds[i], ...))&#123;</span><br><span class="line">            &#x2F;&#x2F;fds[i]的数据处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>select()进行了2次遍历</p><p>一次是被调用时，查询fds中所有的socket，是否有一个或多个socket接收到数据，如果没有任何一个socket收到数据，则将进程挂起(进程状态转换为被阻塞)，并添加到所有socket的等待队列中;</p><p>一次是遍历所有的socket,处理具体收到数据的socket</p><p>因此，select有以下缺点:</p><ul><li><p>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p></li><li><p>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p></li><li><p>由于需要2次遍历，fd太多会导致性能差，select限制了fd的数量为1024</p></li></ul><p>poll的原理和select差不多，只是fds的格式不同</p><p>select低效的原因在于:</p><ul><li><p>实际运行场景下，需要监视的socket相对固定，无需每次都遍历所有fds</p></li><li><p>知道了有socket收到消息，不知道具体是哪个，又徒增一次遍历</p></li></ul><h3 id="epoll-1"><a href="#epoll-1" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是对select和poll的改进，使用了回调的模式</p><p>针对select不知道具体哪个socket有信息的问题，epoll维护一个readylist，保存收到消息的socket</p><p>使用epoll_ctl()维护等待队列，增删待监视的fd</p><p>epoll运作流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int s &#x3D; socket(AF_INET, SOCK_STREAM, 0);   </span><br><span class="line">bind(s, ...)</span><br><span class="line">listen(s, ...)</span><br><span class="line"></span><br><span class="line">int epfd &#x3D; epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); &#x2F;&#x2F;指明需要监听哪个socket上的哪些事件</span><br><span class="line"></span><br><span class="line">while(1)&#123;</span><br><span class="line">    int n &#x3D; epoll_wait(...)</span><br><span class="line">    for(接收到数据的socket)&#123;</span><br><span class="line">        &#x2F;&#x2F;处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事件是一系列事件的按位或，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    监听socket上的输入事件</span><br><span class="line">*&#x2F;</span><br><span class="line">struct epoll_event ev;</span><br><span class="line">ev.events &#x3D; EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, sock_fd, &amp;ev);</span><br></pre></td></tr></table></figure><p>执行epoll_create1()后，系统创建一个eventpoll文件在系统fd列表中。eventpoll和socket一样具有一个等待队列</p><p>使用epoll_ctl()加入需要监听的socket,存储在红黑树上,在对应的socket的等待队列中会加入eventpoll的引用</p><p>当某socket收到数据后，中断程序给eventpoll的readylist中加入该socket的引用</p><p>执行epoll_wait()时，若readylist中有socket的引用，则直接返回，否则阻塞进程，将进程加入eventpoll的等待队列中</p><p>此时socket收到数据，中断程序一边修改readylist，一边唤醒eventpoll等待队列中的进程</p><p>由此可见，由于socket和eventpoll互相存储了对方的引用，eventpoll可以通过查询readylist是否未空，快速发现接收到数据的socket，socket可以快速唤醒被阻塞在它上的进程，提高了运行效率</p><p>复杂度上，select和poll为O(n),epoll为O(1)</p><p>epoll相比于select并不是在所有情况下都要高效，例如在如果有少于1024个文件描述符监听，且大多数socket都是出于活跃繁忙的状态，这种情况下，select要比epoll更为高效，因为epoll会有更多次的系统调用，用户态和内核态会有更加频繁的切换</p><h4 id="水平触发与边缘触发-LT-amp-ET"><a href="#水平触发与边缘触发-LT-amp-ET" class="headerlink" title="水平触发与边缘触发 LT&amp;ET"></a>水平触发与边缘触发 LT&amp;ET</h4><p>poll和select是LT模式。epoll可以指定每个文件描述符为LT或ET模式</p><p>LT模式下epoll相当于一个高效poll，ET模式则是高性能模式</p><p>定义活跃度为活跃连接数比总连接数，当fd数小于1024，且活跃度大于0.6时，poll的效率比epoll要高，因此epoll保留了LT模式</p><blockquote><p>对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通告此事件，直到该事件被处理。而对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。可见，ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此效率要比LT模式高。</p></blockquote><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;epoll.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include&lt;netinet&#x2F;in.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;arpa&#x2F;inet.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned short src_port,dest_port;</span><br><span class="line">int sock_fd;</span><br><span class="line">int flags;</span><br><span class="line">int epollfd,nfds;</span><br><span class="line">struct epoll_event ev,events[MAX_EVENTS];</span><br><span class="line"></span><br><span class="line">struct sockaddr_in src_addr,dest_addr,peer_addr;</span><br><span class="line">int len;</span><br><span class="line">int peer_addr_len;</span><br><span class="line"></span><br><span class="line">int recv_num;</span><br><span class="line">int send_num;</span><br><span class="line"></span><br><span class="line">void init(std::string &amp; src_IP, int16_t src_port)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* 以默认参数创建socket,传输层协议为UDP，网际协议ipv4 *&#x2F;</span><br><span class="line">    sock_fd &#x3D; socket(AF_INET, SOCK_DGRAM,0);</span><br><span class="line">    memset(&amp;src_addr, 0, sizeof(struct sockaddr_in));</span><br><span class="line">    src_addr.sin_family &#x3D; AF_INET; </span><br><span class="line">    src_addr.sin_port &#x3D; htons(src_port); </span><br><span class="line">    src_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY); </span><br><span class="line">    len &#x3D; sizeof(src_addr);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 绑定socket *&#x2F;</span><br><span class="line">    if(bind(sock_fd, (struct sockaddr *)&amp;src_addr, sizeof(src_addr)) &lt; 0)&#123;</span><br><span class="line">        perror(&quot;bind error:&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 允许创建相同port不同ip地址的多个socket描述符*&#x2F;</span><br><span class="line">    const int on &#x3D; 1;</span><br><span class="line">    setsockopt(sock_fd,SOL_SOCKET ,SO_REUSEADDR,&amp;on,sizeof(on));</span><br><span class="line"></span><br><span class="line">    &#x2F;* 创建epoll *&#x2F;</span><br><span class="line">    flags &#x3D; fcntl(sock_fd, F_GETFL, 0);</span><br><span class="line">    flags |&#x3D; O_NONBLOCK;</span><br><span class="line">    fcntl(sock_fd, F_SETFL, flags);</span><br><span class="line">    epollfd &#x3D; epoll_create1(0);</span><br><span class="line">    if (epollfd &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        perror(&quot;epoll_create1&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    ev.events &#x3D; EPOLLIN | EPOLLET;</span><br><span class="line">    ev.data.fd &#x3D; sock_fd;</span><br><span class="line">    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, sock_fd, &amp;ev) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        perror(&quot;epoll_ctl: sock_fd&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_msg(char * recv_buf, int16_t buf_len, int TO)</span><br><span class="line">&#123;</span><br><span class="line">    nfds &#x3D; epoll_wait(epollfd, events, MAX_EVENTS, TO);</span><br><span class="line">    if(nfds &#x3D;&#x3D; -1) return -1;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;nfds;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(events[i].data.fd &#x3D;&#x3D; sock_fd)&#123;</span><br><span class="line">                recv_num &#x3D; recvfrom(sock_fd, recv_buf, buf_len, 0, (struct sockaddr *) &amp;peer_addr,</span><br><span class="line">                        (socklen_t *) &amp;peer_addr_len);</span><br><span class="line"></span><br><span class="line">                if (recv_num &lt; 0) &#123;</span><br><span class="line">                    perror(&quot;recvfrom error:&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                recv_buf[recv_num] &#x3D; &#39;\0&#39;;</span><br><span class="line">                return recv_num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int send_msg(std::string &amp; dest_IP, int16_t dest_port, char * send_buf, int16_t msg_len) &#123;</span><br><span class="line">    memset(&amp;dest_addr, 0, sizeof(struct sockaddr_in)); </span><br><span class="line">    dest_addr.sin_family &#x3D; AF_INET; </span><br><span class="line">    dest_addr.sin_port &#x3D; htons(dest_port); </span><br><span class="line">    dest_addr.sin_addr.s_addr &#x3D; inet_addr(dest_IP.c_str());</span><br><span class="line"></span><br><span class="line">    send_num &#x3D; sendto(sock_fd, send_buf, msg_len, 0, (struct sockaddr *)&amp;dest_addr, len);</span><br><span class="line"></span><br><span class="line">    if(send_num &lt; 0)&#123;</span><br><span class="line">        perror(&quot;sendto error:&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return send_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h1><p>本次实验最后实现得非常丑陋，还做成了阻塞式的一发一答，跟信号有关的应用也只是在实现这个一问一答。时隔一月重新review代码发现完全可以开一个线程来负责某条消息的重发，然后sleep()实现定时任务，简单而有效，查询资料发现linux系统以创建进程线程的开销小而著名，线程的上下文切换可以控制在ns级。</p><p>总结，一是对多线程编程不熟悉，二是对于这种有成熟解决方案的项目应该积极学习而不是闭门造车</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wsl2下的gitproxy设置</title>
      <link href="/2022/01/19/wsl2%E4%B8%8B%E7%9A%84gitproxy%E8%AE%BE%E7%BD%AE/"/>
      <url>/2022/01/19/wsl2%E4%B8%8B%E7%9A%84gitproxy%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h1><p>众所周知，由于github服务器架设在国外，大陆用户访问以及使用git操作较为困难。本文提供windows下linux子系统wsl2的git proxy设置方法，加速使用代理访问github</p><p>萌新时期一个git clone能复制半年确实非常劝退</p><p>首先在powershell下使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure><br>查看当前wsl版本。本文适用于wsl2。</p><p>由于wsl2一些实现上的原因，在开机的时候会被随机分配一个ip地址，而非像wsl1直接使用本机ip 127.0.0.1，所以在wsl2上配置git proxy不能使用以下命令，而要将其中的本机地址127.0.0.1设置为wsl2的ip地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure></p><p>在wsl2中使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;</span><br></pre></td></tr></table></figure><br>可以查询到当前wsl2的ip地址。所以可以使用如下脚本文件设置gitproxy</p><p>set_proxy.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host_ip&#x3D;$(cat &#x2F;etc&#x2F;resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;)</span><br><span class="line">http_port&#x3D;&quot;10809&quot;</span><br><span class="line">git config --global http.proxy &quot;http:&#x2F;&#x2F;$host_ip:$http_port&quot;</span><br><span class="line">git config --global https.proxy &quot;http:&#x2F;&#x2F;$host_ip:$http_port&quot;</span><br></pre></td></tr></table></figure><br>运行.sh文件的时候host_ip后面会多一个空格，而在命令行中直接执行就不会，原因不明。留个坑以后填</p><p>其中http_port根据自己的梯子来设置，我的http port是10809，有的可能是1080</p><p>如果失效，尝试使用export引入环境变量</p><p>set_proxy1.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host_ip&#x3D;$(cat &#x2F;etc&#x2F;resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;)</span><br><span class="line">http_port&#x3D;&quot;10809&quot;</span><br><span class="line">export http_proxy&#x3D;&quot;http:&#x2F;&#x2F;$host_ip:$http_port&quot;</span><br><span class="line">export https_proxy&#x3D;&quot;http:&#x2F;&#x2F;$host_ip:$http_port&quot;</span><br></pre></td></tr></table></figure></p><p>完成后可以在wsl2中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl google.com</span><br></pre></td></tr></table></figure><br>测试有没有连上</p><h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><p>如果设置后仍然没有生效，检查以下设置</p><blockquote><p>梯子开没开<br>&nbsp;<br>注意打开梯子的允许局域网连接<br>&nbsp;<br>(如果是win10)系统搜索“允许应用通过windows防火墙”,给梯子以及相关应用的局域网(专用网络)访问权限。当然最前面那个勾也打上</p></blockquote><h1 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h1><p>问技术问题一定要把运行环境,精细到版本，以及自己所做过的操作，包括指令和报错信息贴出来</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsl2 </tag>
            
            <tag> git </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
